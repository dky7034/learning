# Java 접근 제어자 (Access Modifiers)

Java의 접근 제어자는 클래스, 멤버 변수(필드), 메서드, 생성자에 대한 접근 수준을 제어하여 캡슐화(Encapsulation)를 구현하는 핵심적인 문법입니다. 접근 제어자를 통해 불필요한 정보 노출을 막고, 외부로부터의 무단 변경을 방지하여 객체의 무결성을 보장할 수 있습니다.

## 접근 제어자의 종류

Java는 네 가지 종류의 접근 제어자를 제공하며, 허용 범위가 넓은 순서는 다음과 같습니다.

`private` → `default` (package-private) → `protected` → `public`

| 제어자      | 동일 클래스 | 동일 패키지 | 하위 클래스 (다른 패키지) | 전체 (모든 패키지) |
| ----------- | :---------: | :---------: | :----------------------: | :----------------: |
| `private`   |      O      |      X      |            X             |         X          |
| `default`   |      O      |      O      |            X             |         X          |
| `protected` |      O      |      O      |            O             |         X          |
| `public`    |      O      |      O      |            O             |         O          |

---

### 1. `private`

- **가장 제한적인 접근 수준**입니다.
- `private`으로 선언된 멤버는 **해당 클래스 내부에서만** 접근할 수 있습니다.
- 모든 외부 클래스로부터의 직접적인 호출이나 참조를 막기 때문에, 주로 클래스의 내부 상태를 나타내는 필드를 보호할 때 사용됩니다.

### 2. `default` (Package-Private)

- 접근 제어자를 **명시하지 않았을 때** 적용되는 기본값입니다.
- **같은 패키지 내에 있는 클래스들끼리만** 접근이 허용됩니다.
- `package-private`라는 용어가 그 역할을 더 명확하게 설명해줍니다. 특정 패키지 내에서만 공유되어야 하는 유틸리티 클래스나 헬퍼(Helper) 메서드에 주로 사용됩니다.

### 3. `protected`

- `default` 접근 제어자의 특징을 모두 가집니다. (같은 패키지 내 접근 허용)
- 추가적으로, **패키지가 다르더라도 상속 관계에 있는 하위 클래스라면** 해당 멤버에 접근할 수 있습니다.
- 주로 상속을 통해 확장될 것을 기대하는 클래스의 특정 메서드나 필드를 하위 클래스에게만 공개하고 싶을 때 사용됩니다.

### 4. `public`

- **가장 개방적인 접근 수준**입니다.
- `public`으로 선언된 멤버는 **어디서든** (패키지, 상속 관계 무관) 자유롭게 접근할 수 있습니다.
- 외부에 공개되어 다른 클래스들과 상호작용해야 하는 API 메서드, 상수 필드 등에 사용됩니다.

---

## 접근 제어자 사용 위치

접근 제어자는 다음과 같은 곳에 사용할 수 있습니다.

1.  **클래스 레벨**: `public` 또는 `default`만 가능합니다.
    - `public class MyClass {}` : 모든 패키지에서 이 클래스를 사용할 수 있습니다.
    - `class MyClass {}` : 같은 패키지 내에서만 이 클래스를 사용할 수 있습니다.
2.  **멤버 변수 (필드)**: 모든 접근 제어자 사용 가능
3.  **메서드**: 모든 접근 제어자 사용 가능
4.  **생성자**: 모든 접근 제어자 사용 가능

### 예시 코드

```java
// Speaker.java
public class Speaker {
    // 필드는 외부에서 직접 수정하지 못하도록 private으로 보호
    private int volume;

    // 생성자는 외부에서 호출하여 객체를 생성해야 하므로 public으로 지정
    public Speaker(int initialVolume) {
        if (initialVolume >= 0 && initialVolume <= 100) {
            this.volume = initialVolume;
        }
    }

    // 볼륨을 올리는 메서드 (public API)
    public void volumeUp() {
        if (volume < 100) {
            volume++;
        }
    }

    // 볼륨을 내리는 메서드 (public API)
    public void volumeDown() {
        if (volume > 0) {
            volume--;
        }
    }

    // 현재 볼륨을 보여주는 메서드 (public API)
    public void showVolume() {
        System.out.println("현재 볼륨: " + volume);
    }
}
```

위 예시에서 `volume` 필드는 `private`으로 선언되어 외부에서 직접 `speaker.volume = 1000;`과 같이 값을 변경할 수 없습니다. 대신 `public`으로 공개된 `volumeUp()`, `volumeDown()` 메서드를 통해서만 안전하게 상태를 변경할 수 있습니다. 이것이 바로 **캡슐화**의 핵심 원리입니다.

---

## 접근 제어자의 핵심: 캡슐화와 정보 은닉

접근 제어자의 가장 중요한 목적은 **속성(데이터)과 기능(메서드)을 외부로부터 적절히 숨기는 것(정보 은닉, Information Hiding)**입니다.

- **`private`**: 클래스의 내부 구현을 완전히 숨깁니다. 외부에서는 해당 멤버의 존재조차 알 필요가 없습니다.
- **`default`**: 패키지 단위의 모듈화를 지원합니다. 특정 패키지 내에서만 공유할 기능을 만들 때 유용합니다.
- **`protected`**: 상속을 통한 기능 확장 및 재정의를 유도합니다. 부모 클래스가 특정 기능을 자식 클래스에게만 제공하고 싶을 때 사용합니다.
- **`public`**: 클래스의 공식적인 외부 인터페이스(API)를 정의합니다. 이 클래스를 사용하는 모든 외부 코드와의 소통 창구 역할을 합니다.

올바른 접근 제어자 사용은 객체지향 프로그래밍에서 코드의 안정성, 유지보수성, 재사용성을 높이는 필수적인 습관입니다.
